include "stdlib/stdlib.stala"
include "compiler_out_x86_64.stala"

func main args do

	args sizeof(ptr) + let args # first argument is the name of the compiler

	args ?ptr let input_file_path
	input_file_path try_open_file let input_file
	args sizeof(ptr) + let args

	args sizeof(ptr) + let args # should be -out

	args ?ptr let output_file_path
	# output_file_path remove_file --------------------- TODO:fix
	output_file_path create_and_open_file let out_file
	args sizeof(ptr) + let args
	
	output_file out_file !ptr
	
	input_file parse
	
	input_file close_file
	out_file close_file
end

func output_file do "01234567" end

func print_output_enabled do false end

func out_asm str do
	print_output_enabled if str print end
	output_file ?ptr -1 = if ret end
	output_file ?ptr str file_write_string
end

func out_asm_number val do
	"01234567 01234567" let number_buffer
	number_buffer val 10 int_to_str
	number_buffer out_asm
end

func tmp_label_string do
	"01234567 01234567 01234567 01234567 01234567 01234567 01234567 01234567"
end

func out_if block do
	tmp_label_string let label
	label "block_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label "_" strcat
	label label strlen + block block_get_block_sub_index ++ 10 int_to_str
	label out_jump_zero
end

func out_else block do
	tmp_label_string let label
	label "end_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_jump

	label "block_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label "_" strcat
	label label strlen + block block_get_block_sub_index 10 int_to_str
	label out_label
end

func out_end_if block do
	tmp_label_string let label
	label "block_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label "_" strcat
	label label strlen + block block_get_block_sub_index 10 int_to_str
	label out_label

	label "end_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_label
end

func out_while block do
	tmp_label_string let label
	label "while_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_label
end

func out_while_do block do
	tmp_label_string let label
	label "end_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_jump_zero
end

func out_end_while block do
	tmp_label_string let label
	label "while_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_jump

	label "end_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_label
end

#
# BLOCKS AND BLOCK TYPES
#

func new_block do 4 new_array end
func block_get_block_index block             do block 0             array_get_index end
func block_set_block_index block block_index do block 0 block_index array_set_index end

func block_get_block_sub_index block                 do block 1                 array_get_index end
func block_set_block_sub_index block block_sub_index do block 1 block_sub_index array_set_index end

func block_get_block_type block            do block 2            array_get_index end
func block_set_block_type block block_type do block 2 block_type array_set_index end

func block_type_while    do "while" end
func block_type_while_do do "while do" end
func block_type_if       do "if" end
func block_type_elif     do "elif" end
func block_type_else     do "else" end

#
# TOKENIZER STATUS
#

func status_tokenize_spacers do 1 end
func status_tokenize_token do 2 end
func status_tokenize_string do 3 end
func status_tokenize_escaped do 4 end
func status_tokenize_comment do 5 end
func status_tokenize_number do 6 end

#
# PARSER STATUS
#

func status_parse_source do 1001 end
func status_parse_function_name do 1002 end
func status_parse_function_args do 1003 end
func status_parse_function_body do 1004 end
func status_parse_after_asm do 1005 end
func status_parse_after_let do 1006 end
func status_parse_include do 1007 end

#
# TOKEN PARSER
#

func parse input_file do
	
	" \t\n" let spacers
	"0123456789" let number_chars
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_+-*<=>(){}[]?!:/%" let token_first_chars
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_+-*<=>(){}[]?!:/%" let token_chars
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_+-*<=>(){}[]?!:/% #.:,;" let string_chars
	"nts\\\"" let escaped_chars
	
	1024 malloc let token_string
	1024 malloc let function_string
	
	1024 new_list let block_stack
	0 let block_index 
	
	4096 malloc let include_list
	0 let include_list_length

	4096 new_list let string_list
	4096 new_list let function_list
	4096 new_list let locals_list
	
	function_list "main" list_force_get_index_of_string out_section_code

	status_parse_source let parser_status
	
	# main token loop
	true let parsing_tokens
	while parsing_tokens do
	
		token_string 0 !8
		status_tokenize_spacers let lexer_status
		false let token_is_string
		false let token_is_identifier
		false let token_is_number
		
		#build token
		true let lexing_token
		while lexing_token do
		
			input_file file_read_char let char
		
			lexer_status status_tokenize_spacers = if

				spacers char strchr null != if
					# do nothing
					status_tokenize_spacers let lexer_status
				
				else char "\"" ?8 = elif
					# begining of string
					true let token_is_string
					token_string char strcatchr
					status_tokenize_string let lexer_status
				
				else token_first_chars char strchr null != elif
					# begining of token
					true let token_is_identifier
					token_string char strcatchr
					status_tokenize_token let lexer_status
					
				else number_chars char strchr null != elif
					# number
					true let token_is_number
					token_string char strcatchr
					status_tokenize_token let lexer_status
					
				#else char "-" ?8 = elif #TODO improve
				#	# negative number
				#	true let token_is_number
				#	token_string char strcatchr
				#	status_tokenize_token let lexer_status
				#
				#else char "+" ?8 = elif
				#	# positive number
				#	true let token_is_number
				#	token_string char strcatchr
				#	status_tokenize_token let lexer_status
				#
				else char "#" ?8 = elif
					# begining of comment
					status_tokenize_comment let lexer_status
			
				else char EOF = elif
					# end of file reached
					false let lexing_token
					
				else
					"invalid character: " error
					"?" dup char !8  error
					fail
					
				end
		
			else lexer_status status_tokenize_token = elif
		
				spacers char strchr null != if
					# end of token reached
					false let lexing_token
					
				else token_chars char strchr null != elif
					# continue token
					token_string char strcatchr
					status_tokenize_token let lexer_status
				
				else char EOF = elif
					# end of file reached
					false let lexing_token
					
				else
					"invalid character in token: " error
					"?" dup char !8  error
					fail
					
				end
			
			else lexer_status status_tokenize_string = elif
		
				string_chars char strchr null != if
					# continue string
					token_string char strcatchr
					status_tokenize_string let lexer_status
				
				else char "\\" ?8 = elif
					# escaped character
					token_string char strcatchr
					status_tokenize_escaped let lexer_status
			
				else char "\"" ?8 = elif
					# end of string
					token_string char strcatchr
					false let lexing_token
				
				else
					"invalid character in string: " error
					"?" dup char !8 error
					fail
					
				end
			
			else lexer_status status_tokenize_escaped = elif
		
				escaped_chars char strchr null != if
					# continue string
					token_string char strcatchr
					status_tokenize_string let lexer_status
				
				else
					"invalid character escaped character: " error
					"?" dup char !8 error
					fail
					
				end
			
			else lexer_status status_tokenize_comment = elif
			
				char "\n" ?8 = if
					# end of comment
					status_tokenize_spacers let lexer_status
				
				else char EOF = elif
					# end of file reached
					false let lexing_token
				
				else
					# character in comment
				end
			
			else
				"unimplementad lexer status" error
				 fail
				 
			end
		
		end
		
		# identify token
		parser_status status_parse_source = if
			
			token_string "func" streq if
				locals_list list_clear
				status_parse_function_name let parser_status
			
			else token_string "include" streq elif
				status_parse_include let parser_status
				
			else token_string strlen 0 = elif
				# end of tokens
				include_list_length 0 != if
					# more included files to parse
					include_list_length -- let include_list_length
					include_list include_list_length sizeof(ptr) * + ?ptr let include_string
					
					input_file close_file
					include_string try_open_file let input_file
					
					input_file -1 = if
						"unable to find file: " error
						include_string error
						fail
					end
				else
					# no more files to include, stop parsing
					false let parsing_tokens
				end
				
			else
				"unexpected token in source: " error
				token_string error
				fail
				
			end
		
		else parser_status status_parse_include = elif
			
			token_is_string if
				# file name string
				token_string strlen let token_string_length
				token_string_length 1 - malloc let include_string
				token_string ++ include_string token_string_length 2 - memcpy
				include_string token_string_length + 2 - 0 !8
				
				include_list include_list_length sizeof(ptr) * + include_string !ptr
				include_list_length ++ let include_list_length
				
				status_parse_source let parser_status
			
			else token_string strlen 0 = elif
				"unexpected end of tokens after include: " error
				fail
			
			else
				"unexpected token after include: " error
				token_string error
				fail
				
			end
		
		else parser_status status_parse_function_name = elif
			
			token_is_identifier if
				# the name of the function
				function_string token_string strcpy
				function_list function_string list_force_get_index_of_string out_function_start
				status_parse_function_args let parser_status
			
			else token_string strlen 0 = elif
				"unexpected end of tokens after func" error
				fail
			
			else
				"unexpected token after func: " error
				token_string error
				fail
				
			end
			
		else parser_status status_parse_function_args = elif
			
			token_string "do" streq if
				# end of function argument declaration
				# reverse order of arguments
				locals_list list_reverse
				status_parse_function_body let parser_status
				
			else token_is_identifier elif
				# function argument identifier
				
				# add local variable to list
				locals_list token_string list_force_get_index_of_string out_pop_local
				status_parse_function_args let parser_status
			
			else token_string strlen 0 = elif
				"unexpected end of tokens in function arguments" error
				fail
			
			else
				"unexpected token in function argument: " error
				token_string error
				fail
				
			end
			
		else parser_status status_parse_function_body = elif
			
			token_string "while" streq if
				#-label while:[block index]
				new_block let nblock
				nblock block_index block_set_block_index
				block_index ++ let block_index
				nblock 0 block_set_block_sub_index
				nblock block_type_while block_set_block_type
				block_stack nblock list_push
				nblock out_while
			
			else token_string "do" streq elif
				# conditional jump to next sub block
				#-jz end[block]
				
				# check if this is a while - if
				block_stack list_get_size 0 != if
					block_stack list_peek let nblock
					nblock block_get_block_type block_type_while = if
						nblock block_type_while_do block_set_block_type
						nblock out_while_do
					end
				end
	
			else token_string "if" streq elif
				# conditional jump to next sub block
				#-jz label block[block]:[sub block + 1]
				
				new_block let nblock
				nblock block_index block_set_block_index
				block_index ++ let block_index
				nblock 0 block_set_block_sub_index
				nblock block_type_if block_set_block_type
				block_stack nblock list_push
				nblock out_if
		
			else token_string "elif" streq elif
				# conditional jump to next sub block
				#-jz label block[block]:[sub block + 1]
				
				block_stack list_get_size 0 = if
					"elif can not be the start of a block" error fail
				end
				block_stack list_peek let nblock
				
				nblock block_get_block_type block_type_else != if
					"elif can only come after else" error fail
				end
				
				nblock nblock block_get_block_sub_index ++ block_set_block_sub_index
				nblock block_type_elif block_set_block_type
				nblock out_if
		
			else token_string "else" streq elif
				#-jmp label end:[block index]
				#-label block:[block index]:[sub index]
				
				block_stack list_get_size 0 = if
					"else can not be the start of a block" error fail
				end
				block_stack list_peek let nblock
				
				nblock block_get_block_type block_type_if != 
				nblock block_get_block_type block_type_elif != AND if
					"else can only come after if or elif " error nblock block_get_block_type error fail
				end
				
				nblock nblock block_get_block_sub_index ++ block_set_block_sub_index
				nblock block_type_else block_set_block_type
				nblock out_else
		
			else token_string "end" streq elif
				
				block_stack list_get_size 0 = if
					# end of function
					status_parse_source let parser_status
					out_return
					
				else
					block_stack list_pop let nblock
					
					nblock block_get_block_type block_type_while = if
						"end can not come after while" error fail
						
					else nblock block_get_block_type block_type_while_do = elif
						nblock out_end_while
						
					else nblock block_get_block_type block_type_if = 
					     nblock block_get_block_type block_type_elif = OR
					     nblock block_get_block_type block_type_else = OR elif
					     	nblock nblock block_get_block_sub_index ++ block_set_block_sub_index
							nblock out_end_if
						
					else
						"unknown block type: " error nblock block_get_block_type error fail
					end
				
				end
		
			else token_string "ret" streq elif
				out_return
		
			else token_string "let" streq elif
				status_parse_after_let let parser_status
		
			else token_string "asm" streq elif
				status_parse_after_asm let parser_status
		
			else token_is_number elif #TODO:improve
				# number to push
				# token_string 10 str_to_int out_push_value
				token_string out_push_value
				
			else token_string "-1" streq elif #TODO:improve, quick fix for negative number -1
				# number to push
				# token_string 10 str_to_int out_push_value
				token_string out_push_value
			
			else token_is_identifier elif 
				# identifier is a local variable or function call

				locals_list token_string list_get_index_of_string let local_index
				local_index -1 != if
					# identifier is a local variable
					local_index out_push_local
					
				else
					# identifier is a function
					locals_list list_get_size out_inc_local
					function_list token_string list_force_get_index_of_string out_call_function
					locals_list list_get_size out_dec_local
				end
				
			else token_is_string elif
				#string
				string_list list_get_size let string_index
				token_string strlen ++ malloc let tmp_string
				tmp_string token_string strcpy
				string_list tmp_string list_add
				string_index out_push_string
			
			else token_string strlen 0 = elif
				"unexpected end of tokens in function body" error
				fail
			
			else
				"unexpected token in function body: " error
				token_string error
				fail
				
			end
			
		else parser_status status_parse_after_asm = elif
			
			token_is_string if
				# TODO: unescape string properly
				status_parse_function_body let parser_status
				token_string dup strlen -- + 0 !8
				token_string ++ out_asm
				"\n" out_asm
				
			else token_string strlen 0 = elif
				"unexpected end of tokens after asm" error
				fail
			
			else
				"unexpected token after asm: " error
				token_string error
				fail
				
			end
		
		else parser_status status_parse_after_let = elif
			
			token_is_identifier if
				# local variable identifier
				locals_list token_string list_force_get_index_of_string out_pop_local
				status_parse_function_body let parser_status
				
			else token_string strlen 0 = elif
				"unexpected end of tokens after let" error
				fail
			
			else
				"unexpected token after let: " error
				token_string error
				fail
				
			end
		
		else
			"unimplemented parser status" error
			fail
			
		end
		
	end

	
	# strings

	out_section_data
	
	4096 malloc let unescaped_string_buffer

	0 let string_index
	while string_list list_get_size string_index != do
		
		string_list string_index list_get_index unescaped_string_buffer str_unescape
			
		string_index unescaped_string_buffer out_define_string

		string_index ++ let string_index
	end

	out_section_end
	
end

func str_unescape src dst do
	# ignore first "
	src ++ let src 
	while src ?8 0 != do
		src ?8 let char
		char "\"" ?8 = if
			# must be end of string
			dst 0 !8
		else char "\\" ?8 = elif
			src ++ let src
			src ?8 let char

			char "\\" ?8 = if
				dst "\\" ?8 !8
			else char "\"" ?8 = elif
				dst "\"" ?8 !8
			else char "n" ?8 = elif
				dst "\n" ?8 !8
			else char "t" ?8 = elif
				dst "\t" ?8 !8
			else char "s" ?8 = elif
				dst "\s" ?8 !8 # space
			else
				"invalid escape character" error fail
			end
			dst ++ let dst
		else
			dst char !8
			dst ++ let dst
		end
		src ++ let src
	end
end

