include "stdlib/stdlib.stala"
include "compiler_out_x86_64.stala"

func main args do

	args sizeof(ptr) + let args # first argument is the name of the compiler

	args ?ptr let input_file_path
	input_file_path try_open_file let input_file
	args sizeof(ptr) + let args

	args sizeof(ptr) + let args # should be -out

	args ?ptr let output_file_path
	# output_file_path remove_file --------------------- TODO:fix
	output_file_path create_and_open_file let out_file
	args sizeof(ptr) + let args
	
	output_file out_file !ptr
	
	init_reporter
	input_file_path report_begin_source

	input_file parse

	out_file close_file
end

func output_file do "01234567" end

func print_output_enabled do false end

func out_asm str do
	print_output_enabled if str print end
	output_file ?ptr -1 = if ret end
	output_file ?ptr str file_write_string
end

func out_asm_number val do
	"01234567 01234567" let number_buffer
	number_buffer val 10 int_to_str
	number_buffer out_asm
end

func tmp_label_string do
	"01234567 01234567 01234567 01234567 01234567 01234567 01234567 01234567"
end

func out_if block do
	tmp_label_string let label
	label "block_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label "_" strcat
	label label strlen + block block_get_block_sub_index ++ 10 int_to_str
	label out_jump_zero
end

func out_else block do
	tmp_label_string let label
	label "end_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_jump

	label "block_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label "_" strcat
	label label strlen + block block_get_block_sub_index 10 int_to_str
	label out_label
end

func out_end_if block do
	tmp_label_string let label
	label "block_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label "_" strcat
	label label strlen + block block_get_block_sub_index 10 int_to_str
	label out_label

	label "end_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_label
end

func out_while block do
	tmp_label_string let label
	label "while_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_label
end

func out_while_do block do
	tmp_label_string let label
	label "end_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_jump_zero
end

func out_end_while block do
	tmp_label_string let label
	label "while_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_jump

	label "end_" strcpy
	label label strlen + block block_get_block_index 10 int_to_str
	label out_label
end

#
# ERROR REPORTING
#

func reporter_struct do "01234567" end

func init_reporter do
	8 new_array let reporter
	reporter_struct reporter !ptr
	"" report_begin_source
	"" report_begin_function
end

func reporter_report do
	4096 malloc let str
	str "source: " strcpy
	str 0 reporter_get_index strcat
	str "\nfunction: " strcat
	str 1 reporter_get_index strcat
	str "\nline: " strcat
	str str strlen + 2 reporter_get_index 10 int_to_str
	str "\n" strcat
	str
end

func reporter_get_index index do reporter_struct ?ptr index array_get_index end
func reporter_set_index index value do reporter_struct ?ptr index value array_set_index end

func report_begin_source source do 0 source reporter_set_index 2 1 reporter_set_index end
func report_end_source do 0 "" reporter_set_index end

func report_begin_function function do 1 function reporter_set_index end
func report_end_function do 1 "" reporter_set_index end

func report_newline do 2 2 reporter_get_index ++ reporter_set_index end

#
# BLOCKS AND BLOCK TYPES
#

func new_block do 4 new_array end
func block_get_block_index block             do block 0             array_get_index end
func block_set_block_index block block_index do block 0 block_index array_set_index end

func block_get_block_sub_index block                 do block 1                 array_get_index end
func block_set_block_sub_index block block_sub_index do block 1 block_sub_index array_set_index end

func block_get_block_type block            do block 2            array_get_index end
func block_set_block_type block block_type do block 2 block_type array_set_index end

func block_type_while    do "while" end
func block_type_while_do do "while do" end
func block_type_if       do "if" end
func block_type_elif     do "elif" end
func block_type_else     do "else" end

#
# TOKENIZER STATUS
#

func status_tokenize_spacers do 1 end
func status_tokenize_token   do 2 end
func status_tokenize_string  do 3 end
func status_tokenize_escaped do 4 end
func status_tokenize_comment do 5 end
func status_tokenize_number  do 6 end

#
# PARSER STATUS
#

func status_parse_source        do 1001 end
func status_parse_function_name do 1002 end
func status_parse_function_args do 1003 end
func status_parse_function_body do 1004 end
func status_parse_after_asm     do 1005 end
func status_parse_after_let     do 1006 end
func status_parse_include       do 1007 end

#
# TOKEN PARSER
#

func parse input_file do
	
	"\s\t\n" let spacers
	"0123456789" let number_chars
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_+-*<=>(){}[]?!:/%" let token_first_chars
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_+-*<=>(){}[]?!:/%" let token_chars
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_+-*<=>(){}[]?!:/% #.:,;" let string_chars
	"nts\\\"" let escaped_chars
	
	1024 malloc let token_string
	1024 malloc let function_string
	1024 malloc let tmp_buffer

	new_list let block_stack
	0 let block_index 
	
	new_list let all_include_list
	new_list let to_include_list
	new_list let string_list
	new_list let function_list
	new_list let declared_functions_list
	new_list let locals_list
	
	function_list "main" list_force_get_index_of_string out_section_code

	status_parse_source let parser_status
	
	# main token loop
	true let parsing_tokens
	while parsing_tokens do
	
		token_string 0 !8
		status_tokenize_spacers let lexer_status
		false let token_is_string
		false let token_is_identifier
		false let token_is_number
		
		#build token
		true let lexing_token
		while lexing_token do
		
			input_file file_read_char let char
			char "\n" ?8 = if
				report_newline
			end

			lexer_status status_tokenize_spacers = if

				spacers char strchr null != if
					# do nothing
					status_tokenize_spacers let lexer_status
				
				else char "\"" ?8 = elif
					# begining of string
					true let token_is_string
					token_string char strcatchr
					status_tokenize_string let lexer_status
				
				else token_first_chars char strchr null != elif
					# begining of token
					true let token_is_identifier
					token_string char strcatchr
					status_tokenize_token let lexer_status
					
				else number_chars char strchr null != elif
					# number
					true let token_is_number
					token_string char strcatchr
					status_tokenize_token let lexer_status
					
				#else char "-" ?8 = elif #TODO improve
				#	# negative number
				#	true let token_is_number
				#	token_string char strcatchr
				#	status_tokenize_token let lexer_status
				#
				#else char "+" ?8 = elif
				#	# positive number
				#	true let token_is_number
				#	token_string char strcatchr
				#	status_tokenize_token let lexer_status
				#
				else char "#" ?8 = elif
					# begining of comment
					status_tokenize_comment let lexer_status
			
				else char EOF = elif
					# end of file reached
					false let lexing_token
					
				else
					"invalid character: " error
					"?\n" dup char !8  error
					reporter_report error fail
					
				end
		
			else lexer_status status_tokenize_token = elif
		
				spacers char strchr null != if
					# end of token reached
					false let lexing_token
					
				else token_chars char strchr null != elif
					# continue token
					token_string char strcatchr
					status_tokenize_token let lexer_status
				
				else char EOF = elif
					# end of file reached
					false let lexing_token
					
				else
					"invalid character in token: " error
					"?\n" dup char !8  error
					reporter_report error fail
					
				end
			
			else lexer_status status_tokenize_string = elif
		
				string_chars char strchr null != if
					# continue string
					token_string char strcatchr
					status_tokenize_string let lexer_status
				
				else char "\\" ?8 = elif
					# escaped character
					token_string char strcatchr
					status_tokenize_escaped let lexer_status
			
				else char "\"" ?8 = elif
					# end of string
					token_string char strcatchr
					false let lexing_token
				
				else
					"invalid character in string: " error
					"?\n" dup char !8 error
					reporter_report error fail
					
				end
			
			else lexer_status status_tokenize_escaped = elif
		
				escaped_chars char strchr null != if
					# continue string
					token_string char strcatchr
					status_tokenize_string let lexer_status
				
				else
					"invalid character escaped character: " error
					"?\n" dup char !8 error
					reporter_report error fail
					
				end
			
			else lexer_status status_tokenize_comment = elif
			
				char "\n" ?8 = if
					# end of comment
					status_tokenize_spacers let lexer_status
				
				else char EOF = elif
					# end of file reached
					false let lexing_token
				
				else
					# character in comment
				end
			
			else
				"unimplementad lexer status\n" error fail
				 
			end
		
		end
		
		# identify token
		parser_status status_parse_source = if
			
			token_string "func" streq if
				locals_list list_clear
				status_parse_function_name let parser_status
			
			else token_string "include" streq elif
				status_parse_include let parser_status
				
			else token_string strlen 0 = elif
				# end of tokens
				to_include_list list_get_size 0 != if
					# more included files to parse
					to_include_list list_pop let include_string
					
					input_file close_file
					include_string try_open_file let input_file

					# TODO: debug information output
					#"opening file: " print include_string print " fd: " print input_file print_int "\n" print

					input_file -1 = if
						"unable to find file: " error
						include_string error "\n" error
						reporter_report error fail
					end
					include_string report_begin_source
				else
					# no more files to include, stop parsing
					input_file close_file
					false let parsing_tokens
				end
				
			else
				"unexpected token in source: " error
				token_string error "\n" error
				reporter_report error fail
				
			end
		
		else parser_status status_parse_include = elif
			
			token_is_string if
				# get file name from string
				tmp_buffer token_string str_unescape
				tmp_buffer strdup let include_string

				# check that this source has not yet been included
				all_include_list include_string list_get_index_of_string -1 = if
					all_include_list include_string list_push
					to_include_list include_string list_push
				else
					"multiple include for the same source: " error include_string error "\n" error
					reporter_report error fail
				end
				
				status_parse_source let parser_status
			
			else token_string strlen 0 = elif
				"unexpected end of tokens after include\n" error
				reporter_report error fail
			
			else
				"unexpected token after include: " error
				token_string error "\n" error
				reporter_report error fail
				
			end
		
		else parser_status status_parse_function_name = elif
			
			token_is_identifier if
				# the name of the function
				function_string token_string strcpy
				function_string report_begin_function

				declared_functions_list function_string list_get_index_of_string -1 != if
					"multiple declarations of function: " error function_string error "\n" error
					reporter_report error fail
				end

				declared_functions_list function_string strdup list_add
				function_list function_string list_force_get_index_of_string out_function_start
				status_parse_function_args let parser_status
			
			else token_string strlen 0 = elif
				"unexpected end of tokens after func\n" error
				reporter_report error fail
			
			else
				"unexpected token after func: " error
				token_string error "\n" error
				reporter_report error fail
				
			end
			
		else parser_status status_parse_function_args = elif
			
			token_string "do" streq if
				# end of function argument declaration
				# reverse order of arguments
				locals_list list_reverse
				status_parse_function_body let parser_status
				
			else token_is_identifier elif
				# function argument identifier
				
				# add local variable to list
				locals_list token_string list_force_get_index_of_string out_pop_local
				status_parse_function_args let parser_status
			
			else token_string strlen 0 = elif
				"unexpected end of tokens in function arguments\n" error
				reporter_report error fail
			
			else
				"unexpected token in function argument: " error
				token_string error "\n" error
				reporter_report error fail
				
			end
			
		else parser_status status_parse_function_body = elif
			
			token_string "while" streq if
				new_block let nblock
				nblock block_index block_set_block_index
				block_index ++ let block_index
				nblock 0 block_set_block_sub_index
				nblock block_type_while block_set_block_type
				block_stack nblock list_push
				nblock out_while
			
			else token_string "do" streq elif

				# check if this is a while - if
				block_stack list_get_size 0 != if
					block_stack list_peek let nblock
					nblock block_get_block_type block_type_while = if
						nblock block_type_while_do block_set_block_type
						nblock out_while_do
					end
				end
	
			else token_string "if" streq elif

				new_block let nblock
				nblock block_index block_set_block_index
				block_index ++ let block_index
				nblock 0 block_set_block_sub_index
				nblock block_type_if block_set_block_type
				block_stack nblock list_push
				nblock out_if
		
			else token_string "elif" streq elif

				block_stack list_get_size 0 = if
					"elif can not be the start of a block\n" error
					reporter_report error fail
				end
				block_stack list_peek let nblock
				
				nblock block_get_block_type block_type_else != if
					"elif can only come after else\n" error
					reporter_report error fail
				end
				
				nblock nblock block_get_block_sub_index ++ block_set_block_sub_index
				nblock block_type_elif block_set_block_type
				nblock out_if
		
			else token_string "else" streq elif

				block_stack list_get_size 0 = if
					"else can not be the start of a block\n" error
					reporter_report error fail
				end
				block_stack list_peek let nblock
				
				nblock block_get_block_type block_type_if != 
				nblock block_get_block_type block_type_elif != AND if
					"else can only come after if or elif, not: " error nblock block_get_block_type error "\n" error
					reporter_report error fail
				end
				
				nblock nblock block_get_block_sub_index ++ block_set_block_sub_index
				nblock block_type_else block_set_block_type
				nblock out_else
		
			else token_string "end" streq elif
				
				block_stack list_get_size 0 = if
					# end of function
					report_end_function
					status_parse_source let parser_status
					function_list function_string list_force_get_index_of_string out_function_end
					
				else
					block_stack list_pop let nblock
					
					nblock block_get_block_type block_type_while_do = if
						nblock out_end_while
						
					else nblock block_get_block_type block_type_if = 
					     nblock block_get_block_type block_type_elif = OR
					     nblock block_get_block_type block_type_else = OR elif
					     	nblock nblock block_get_block_sub_index ++ block_set_block_sub_index
						nblock out_end_if
						
					else
						"invalid block type before end: " error nblock block_get_block_type error "\n" error
						reporter_report error fail
					end
				
				end
		
			else token_string "ret" streq elif
				function_list function_string list_force_get_index_of_string out_return
		
			else token_string "let" streq elif
				status_parse_after_let let parser_status
		
			else token_string "asm" streq elif
				status_parse_after_asm let parser_status
		
			else token_is_number elif #TODO:improve
				# number to push
				# token_string 10 str_to_int out_push_value
				token_string out_push_value
				
			else token_string "-1" streq elif #TODO:improve, quick fix for negative number -1
				# number to push
				# token_string 10 str_to_int out_push_value
				token_string out_push_value
			
			else token_is_identifier elif 
				# identifier is a local variable or function call

				locals_list token_string list_get_index_of_string let local_index
				local_index -1 != if
					# identifier is a local variable
					local_index out_push_local
					
				else
					# identifier is a function
					locals_list list_get_size out_inc_local
					function_list token_string list_force_get_index_of_string out_call_function
					locals_list list_get_size out_dec_local
				end
				
			else token_is_string elif
				# string
				string_list list_get_size let string_index
				string_list token_string strdup list_add
				string_index out_push_string
			
			else token_string strlen 0 = elif
				"unexpected end of tokens in function body\n" error
				reporter_report error fail
			
			else
				"unexpected token in function body: " error
				token_string error "\n" error
				reporter_report error fail
				
			end
			
		else parser_status status_parse_after_asm = elif
			
			token_is_string if
				# output assembly
				tmp_buffer token_string str_unescape
				tmp_buffer "\n" strcat
				tmp_buffer out_asm
				status_parse_function_body let parser_status
				
			else token_string strlen 0 = elif
				"unexpected end of tokens after asm\n" error
				reporter_report error fail
			
			else
				"unexpected token after asm: " error
				token_string error "\n" error
				reporter_report error fail
				
			end
		
		else parser_status status_parse_after_let = elif
			
			token_is_identifier if
				# local variable identifier
				locals_list token_string list_force_get_index_of_string out_pop_local
				status_parse_function_body let parser_status
				
			else token_string strlen 0 = elif
				"unexpected end of tokens after let\n" error
				reporter_report error fail
			
			else
				"unexpected token after let: " error
				token_string error "\n" error
				reporter_report error fail
				
			end
		
		else
			"unimplemented parser status\n" error fail
			
		end
		
	end
	
	# check that all referenced functions have been declared
	0 let i
	while i function_list list_get_size != do
		function_list i list_get_index let function_to_check
		declared_functions_list function_to_check list_get_index_of_string -1 = if
			"undefined function: " error function_to_check error "\n" error
			reporter_report error fail
		end
		i ++ let i
	end
	
	# strings
	out_section_data

	0 let i
	while string_list list_get_size i != do
		tmp_buffer string_list i list_get_index str_unescape
		i tmp_buffer out_define_string
		i ++ let i
	end
	out_section_end
	
end

func str_unescape dst src do
	# ignore first "
	src ++ let src 
	while src ?8 0 != do
		src ?8 let char
		char "\"" ?8 = if
			# must be end of string
			dst 0 !8
		else char "\\" ?8 = elif
			src ++ let src
			src ?8 let char

			char "\\" ?8 = if
				dst "\\" ?8 !8
			else char "\"" ?8 = elif
				dst "\"" ?8 !8
			else char "n" ?8 = elif
				dst "\n" ?8 !8
			else char "t" ?8 = elif
				dst "\t" ?8 !8
			else char "s" ?8 = elif
				dst "\s" ?8 !8 # space
			else
				# TODO: should the error reporter be here?
				"invalid escape character: " error "?\n" dup char !8 error
				reporter_report error fail
			end
			dst ++ let dst
		else
			dst char !8
			dst ++ let dst
		end
		src ++ let src
	end
end

