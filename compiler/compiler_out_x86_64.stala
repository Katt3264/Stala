
func print_comments_enabled do false end

func bytes_per_register do 8 end
func local_inlined_max do 16 end
func func_auto_reserve do 256 end

#
# PRE DEFINED FUNCTIONS
#

func out_func_push_reg reg do

	reg "rax" streq if
		"rbx" let tmp_reg
	else
		"rax" let tmp_reg
	end

	"\n" out_asm
	";; push " out_asm reg out_asm " to the data stack\n" out_asm
	"push_" out_asm reg out_asm ":\n" out_asm								# declare the function
	"push " out_asm tmp_reg out_asm "\n" out_asm 							# save the temporary register
	"mov " out_asm tmp_reg out_asm ", [rel dsp]\n" out_asm						# load DSP into the temporary register
	"mov [" out_asm tmp_reg out_asm "], " out_asm reg out_asm "\n" out_asm				# save the target register to the data stack
	"add " out_asm tmp_reg out_asm ", " out_asm bytes_per_register out_asm_number "\n" out_asm	# move up to a empty element
	"mov [rel dsp], " out_asm tmp_reg out_asm "\n" out_asm						# save the temporary register to DSP
	"pop " out_asm tmp_reg out_asm "\n" out_asm 							# restore the temporary register
	"ret\n" out_asm
end

func out_func_pop_reg reg do # TODO: change working register

	reg "rax" streq if
		"rbx" let tmp_reg
	else
		"rax" let tmp_reg
	end

	"\n" out_asm
	";; pop " out_asm reg out_asm " from the data stack\n" out_asm
	"pop_" out_asm reg out_asm ":\n" out_asm								# declare the function
	"push " out_asm tmp_reg out_asm "\n" out_asm 							# save the temporary register
	"mov " out_asm tmp_reg out_asm ", [rel dsp]\n" out_asm						# load DSP into the temporary register
	"sub " out_asm tmp_reg out_asm ", " out_asm bytes_per_register out_asm_number "\n" out_asm	# move down to a valid element
	"mov " out_asm reg out_asm ", [" out_asm tmp_reg out_asm "]\n" out_asm				# load the target register with the element on the data stack
	"mov [rel dsp], " out_asm tmp_reg out_asm "\n" out_asm						# save the temporary register to DSP
	"pop " out_asm tmp_reg out_asm "\n" out_asm 							# restore the temporary register
	"ret\n" out_asm
end

func out_func_push_local index do
	"\n" out_asm
	";; push local variable with index " out_asm index out_asm_number " \n" out_asm
	"pushl_" out_asm index out_asm_number ":\n" out_asm
	"mov rbx, [rel lsp]\n" out_asm
	"mov rax, [rbx + " out_asm index bytes_per_register * out_asm_number "]\n" out_asm
	"call push_rax\n" out_asm
	"ret\n" out_asm
end

func out_func_pop_local index do
	"\n" out_asm
	";; pop local variable with index " out_asm index out_asm_number " \n" out_asm
	"popl_" out_asm index out_asm_number ":\n" out_asm
	"call pop_rax\n" out_asm
	"mov rbx, [rel lsp]\n" out_asm
	"mov [rbx + " out_asm index bytes_per_register * out_asm_number "], rax\n" out_asm
	"ret\n" out_asm
end

#
# ASSEMBLY OUTPUT
#

func out_section_code main_function_index do
	"BITS 64\n" out_asm
	"global _main\n" out_asm
	"section .text\n" out_asm
	"\n" out_asm

	"_main:\n" out_asm

	# memory region
	"lea rax, [rel mem]\n" out_asm
	"mov [rel mem_ptr], rax\n" out_asm

	# data stack
	"lea rax, [rel data_stack]\n" out_asm
	"mov [rel dsp], rax\n" out_asm

	# locals stack
	"lea rax, [rel local_stack]\n" out_asm
	"mov [rel lsp], rax\n" out_asm

	# ENVP
	"mov rax, rdx\n" out_asm
	"call push_rax\n" out_asm

	# ARGC
	"mov rax, rdi\n" out_asm
	"call push_rax\n" out_asm

	# ARGV
	"mov rax, rsi\n" out_asm
	"call push_rax\n" out_asm

	main_function_index out_call_function

	"_exit:\n" out_asm
	"mov rax, 0x2000001\n" out_asm
	"mov rdi, 0\n" out_asm
	"syscall\n" out_asm
	"\n" out_asm

	# utility functions

	"\n" out_asm
	";; start of utility functions\n" out_asm

	"rax" out_func_push_reg
	"rax" out_func_pop_reg

	"rbx" out_func_push_reg
	"rbx" out_func_pop_reg

	"rcx" out_func_push_reg
	"rcx" out_func_pop_reg

	"rdx" out_func_push_reg
	"rdx" out_func_pop_reg

	"rdi" out_func_push_reg
	"rdi" out_func_pop_reg

	"rsi" out_func_push_reg
	"rsi" out_func_pop_reg

	"r10" out_func_push_reg
	"r10" out_func_pop_reg

	"r9" out_func_push_reg
	"r9" out_func_pop_reg

	"r8" out_func_push_reg
	"r8" out_func_pop_reg

	0 let i
	while i local_inlined_max < do
		i out_func_push_local
		i out_func_pop_local
		i ++ let i
	end

	"\n" out_asm
	";; end of utility functions\n" out_asm

end

func out_section_data do
	"\n" out_asm
	"section .data\n" out_asm
	"\n" out_asm
end

func out_section_end do
	"\n" out_asm
	"section .bss\n" out_asm
	";; some global vars\n" out_asm
	"\n" out_asm

	";; stack for local variables\n" out_asm
	"lsp: resq 1\n" out_asm
	"local_stack: resq 65536\n" out_asm
	"local_stack_end:\n" out_asm
	"\n" out_asm

	";; stack for data elements\n" out_asm
	"dsp: resq 1\n" out_asm
	"data_stack: resq 65536\n" out_asm
	"data_stack_end:\n" out_asm
	"\n" out_asm

	";; memory region\n" out_asm
	"mem_ptr: resq 1\n" out_asm
	"mem: resb 16777216\n" out_asm
	"mem_end:\n" out_asm
	"\n" out_asm
end

func out_call_function index do
	print_comments_enabled if ";; function call\n" out_asm  end
	"call func_" out_asm index out_asm_number "\n" out_asm
end

func out_function_start index do
	"\n" out_asm
	"func_" out_asm index out_asm_number ":\n" out_asm
	func_auto_reserve out_inc_local
end

func out_return index do
	print_comments_enabled if ";; return\n" out_asm end
	"jmp end_func_" out_asm index out_asm_number "\n" out_asm
end

func out_function_end index do
	print_comments_enabled if ";; end of function\n" out_asm end
	"end_func_" out_asm index out_asm_number ":\n" out_asm
	func_auto_reserve out_dec_local
	"ret\n" out_asm
end

func out_push_local index do

	# reduce final .asm size by using a existing function
	index local_inlined_max < if
		"call pushl_" out_asm index out_asm_number "\n" out_asm
		ret
	end

	print_comments_enabled if ";; push local variable\n" out_asm  end
	"mov rbx, [rel lsp]\n" out_asm
	"mov rax, [rbx + " out_asm index bytes_per_register * out_asm_number "]\n" out_asm
	"call push_rax\n" out_asm
end

func out_pop_local index do

	# reduce final .asm size by using a existing function
	index local_inlined_max < if
		"call popl_" out_asm index out_asm_number "\n" out_asm
		ret
	end

	print_comments_enabled if ";; pop local variable\n" out_asm  end
	"call pop_rax\n" out_asm
	"mov rbx, [rel lsp]\n" out_asm
	"mov [rbx + " out_asm index bytes_per_register * out_asm_number "], rax\n" out_asm
end

func out_inc_local value do

	value func_auto_reserve < if
		# called function reserves enough space
		ret
	end

	print_comments_enabled if ";; increment local pointer\n" out_asm  end
	"mov rax, [rel lsp]\n" out_asm
	"add rax, " out_asm value bytes_per_register * out_asm_number "\n" out_asm
	"mov [rel lsp], rax\n" out_asm
end

func out_dec_local value do

	value func_auto_reserve < if
		# called function reserved enough space
		ret
	end

	print_comments_enabled if ";; decrement local pointer\n" out_asm  end
	"mov rax, [rel lsp]\n" out_asm
	"sub rax, " out_asm value bytes_per_register * out_asm_number "\n" out_asm
	"mov [rel lsp], rax\n" out_asm
end

func out_push_value str do
	print_comments_enabled if ";; push number\n" out_asm  end
	"mov rax, " out_asm str out_asm "\n" out_asm
	"call push_rax\n" out_asm
end

func out_push_string string_index do
	print_comments_enabled if ";; push number\n" out_asm end
	"lea rax, [rel str_" out_asm string_index out_asm_number "]\n" out_asm
	"call push_rax\n" out_asm
end

func out_define_string string_index string do
	"str_" out_asm string_index out_asm_number ": db " out_asm
	while string ?8 0 != do
		string ?8 out_asm_number
		"," out_asm
		string ++ let string
	end
	"0\n" out_asm
end

func out_label label do
	print_comments_enabled if ";; label\n" out_asm end
	label out_asm ":\n" out_asm
end

func out_jump label do
	print_comments_enabled if ";; jump\n" out_asm end
	"jmp " out_asm label out_asm "\n" out_asm
end

func out_jump_zero label do
	print_comments_enabled if ";; jump zero\n" out_asm end
	"call pop_rax\n" out_asm
	"test rax, rax\n" out_asm
	"jz " out_asm label out_asm "\n" out_asm
end
