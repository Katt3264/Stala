func main do
	"hello world" println
end

func println str do
	str str strlen stdout
	"\n" 1 stdout
end

func strlen str do
	11
end

func stdout buf len do
	1 buf len write let q
end

#
# fd - file descriptor to write to
# buf - buffer to write from
# len - number of bytes to attempt to write
#
# len - number of bytes written, -1 on error
#
func write fd buf len do
	0x2000004 fd buf len syscall4
end

func syscall4 num arg1 arg2 arg3 do
	num arg1 arg2 arg3 0 0 0 syscall7
end

func syscall7 num arg1 arg2 arg3 arg4 arg5 arg6 do
	
	num arg1 arg2 arg3 arg4 arg5 arg6
	
	asm "sub rbp, 8"
	asm "mov r9, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov r8, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov r10, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov rdx, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov rsi, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov rdi, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	asm "push rbp"
	asm "mov rbp, rsp"
	asm "syscall"
	asm "pop rbp"
	
	# this is how a error is detected
	asm "jc .syscall_error"
	
	asm "mov [rbp], rax"
	asm "add rbp, 8"
	asm "jmp .syscall_end"
	
	asm ".syscall_error:"
	asm "mov rax, -1"
	asm "mov [rbp], rax"
	asm "add rbp, 8"
	
	asm ".syscall_end:"
	# return is on the stack
end