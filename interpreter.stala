

func interpret path do
	
	"BEGIN INTERPRETER" println
	
	1024 malloc let line_buffer
	64000 new_list let lines
	
	path try_open_file let fd
	
	true let reading
	while reading true = if
		fd line_buffer 255 file_read_line
		line_buffer println
		
		line_buffer strlen 0 = if
			false let reading
		else
			line_buffer strlen ++ malloc let tmp_line_buffer
			tmp_line_buffer line_buffer strcpy
			lines tmp_line_buffer list_add
		end
		
	end
	
	"BEGIN RUN" println
	
	0 let instruction_ptr
	1024 malloc let data_stack
	0 let data_stack_ptr
	
	true let running
	while running instruction_ptr lines list_get_size < AND if
		
		lines instruction_ptr list_get_index let current_instruction
		
		current_instruction "label " strstr current_instruction = if
			#label
			current_instruction "label " strlen + let label_string
			"[LABEL] " print
			label_string println
		
		else current_instruction "push " strstr current_instruction = elif
			# push number
			current_instruction "push " strlen + 10 str_to_int let value
			data_stack data_stack_ptr sizeof(ptr) * + value !ptr
			data_stack_ptr ++ let data_stack_ptr
			
			"[PUSH] " print
			value print_int
			"" println
		
		else current_instruction "push_local " strstr current_instruction = elif
			# push local variable
			current_instruction "push_local " strlen + 10 str_to_int let value
			#TODO: push value --------------------------------
			
			"[PUSH LOCAL] " print
			value print_int
			"" println
			
		else current_instruction "pop_local " strstr current_instruction = elif
			# push local variable
			current_instruction "pop_local " strlen + 10 str_to_int let value
			#TODO: push value --------------------------------
			
			"[POP LOCAL] " print
			value print_int
			"" println
			
		else current_instruction "call " strstr current_instruction = elif
			# TODO: inc/dec local ptr go to line with label -----------------------------
			current_instruction "call " strlen + let n_string
			
			n_string " " strstr ++ let c_string
			
			"01234567" let tmp_string
			c_string n_string - -- let n_length
			
			n_string tmp_string n_length memcpy
			tmp_string n_length + 0 !8
			tmp_string 10 str_to_int let c_val
		
			"[CALL] " print
			"[" print "01234567" dup c_val 10 int_to_str print "] " print
			c_string println
		
		else current_instruction "jz " strstr current_instruction = elif
			#jump on zero
			current_instruction "jz " strlen + let label_string
			"[JUMP ZERO] " print
			label_string println
		
		else current_instruction "jmp " strstr current_instruction = elif
			#jump
			current_instruction "jmp " strlen + let label_string
			"[JUMP] " print
			label_string println
			
		else current_instruction "return" streq elif
			# TODO: go return address
			"[RETURN] " println
			
		else current_instruction "intrinsic " strstr current_instruction = elif
			
			current_instruction "intrinsic " strlen + let i_string
			
			i_string "add" streq if
				# intrinsic add
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_a tmp_b + !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[ADD]" println
				
			else i_string "sub" streq elif
				# intrinsic sub
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a - !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[SUB]" println
				
			else i_string "mul" streq elif
				# intrinsic mul
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a * !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[MUL]" println
				
			else i_string "divmod" streq elif
				# intrinsic divmod
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a DIVMOD !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[DIVMOD]" println
				
			else i_string "right_shift" streq elif
				# intrinsic right shift
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a >> !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[RIGHT SHIFT]" println
			
			else i_string "and" streq elif
				# intrinsic and
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a AND !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[AND]" println
				
			else i_string "not" streq elif
				# intrinsic not
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_a NOT !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[NOT]" println
				
			else i_string "equals" streq elif
				# intrinsic equals
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a = !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[EQUALS]" println
				
			else i_string "greater_than" streq elif
				# intrinsic greater than
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a > !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[GREATER THAN]" println
				
			else i_string "syscall7" streq elif
				# intrinsic syscall7
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
				
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_c
				
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_d
				
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_e
				
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_f
				
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_g
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_g tmp_f tmp_e tmp_d tmp_c tmp_b tmp_a syscall7 !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[SYSCALL 7]" println
			
			else i_string "read_byte" streq elif
				# intrinsic read byte TODO: implement -------------------------------
				#pop adress
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_a ?8 !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[READ BYTE]" println
				
			else i_string "write_byte" streq elif
				# intrinsic write byte TODO: implement -------------------------------
				#pop value
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
				#pop address
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a !8 !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[WRITE BYTE]" println
			
			else i_string "read_word" streq elif
				# intrinsic read word TODO: implement -------------------------------
				#pop adress
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_a ?ptr !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[READ WORD]" println
				
			else i_string "write_word" streq elif
				# intrinsic write word TODO: implement -------------------------------
				#pop value
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_a
				#pop address
				#data_stack_ptr -- let data_stack_ptr
				#data_stack data_stack_ptr sizeof(ptr) * + ?ptr let tmp_b
			
				#data_stack data_stack_ptr sizeof(ptr) * + tmp_b tmp_a !ptr !ptr
				#data_stack_ptr ++ let data_stack_ptr
		
				"[WRITE WORD]" println
				
			else i_string "mem_start" streq elif
				#start addres of memory
				data_stack data_stack_ptr sizeof(ptr) * + 0 !ptr
				data_stack_ptr ++ let data_stack_ptr
				"[MEMSTART]" println
			
			else
				"unknown intrinsic: " error
				i_string error
				fail
			
			end
			
			
		else
			"unknown line: " error
			current_instruction error
			fail
			
		end
		
		#data_stack data_stack_ptr print_stack
		instruction_ptr ++ let instruction_ptr
	end


end

func print_stack stack length do

	0 let index
	while index length != if
		stack index sizeof(ptr) * + ?ptr let value
		"[" print
		value print_int
		"] " print
		index ++ let index
	end
	"" println
end


