# x86 64 asm

#func local_bottom do
#	# move local bottom to rax
#	asm "lea rax, [rel loc_stack]"
#
#	# push rax
#	asm "mov [rbp], rax"
#	asm "add rbp, 8"
#end

#func local_ptr do
#	# move local bottom to rax
#	asm "mov rax, [rel loc_stack_ptr]"
#
#	# push rax
#	asm "mov [rbp], rax"
#	asm "add rbp, 8"
#end

#func data_bottom do
#	# move to rax
#	asm "lea rax, [rel dat_stack]"
#
#	# push rax
#	asm "mov [rbp], rax"
#	asm "add rbp, 8"
#end

# ptr to top element of data stack
#func data_ptr do
#	# move to rax
#	asm "mov rax, rbp"
#
#	# push rax
#	asm "mov [rbp], rax"
#	asm "add rbp, 8"
#	8 -
#end

func mem_start do
	# move mem to rax
	asm "lea rax, [rel mem]"

	# push rax
	asm "mov [rbp], rax"
	asm "add rbp, 8"
end

func sizeof(ptr) do
	8
end

func null do 0 end

func dup x do x x end

# addr value
func !ptr do	
	# pop rbx
	asm "sub rbp, 8"
	asm "mov rbx, [rbp]"
	
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	asm "mov [rax], rbx"
end

# addr
func ?ptr do
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	asm "mov rbx, [rax]"
	
	# push rbx
	asm "mov [rbp], rbx"
	asm "add rbp, 8"
end

# addr value
func !8 do	
	# pop rbx
	asm "sub rbp, 8"
	asm "mov rbx, [rbp]"
	
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	asm "mov [rax], bl"
end

# addr
func ?8 do
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	asm "movzx rbx, byte [rax]"
	
	# push rbx
	asm "mov [rbp], rbx"
	asm "add rbp, 8"
end

func + do	
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	# pop rbx
	asm "sub rbp, 8"
	asm "mov rbx, [rbp]"
	
	asm "add rbx, rax"
	
	# push rbx
	asm "mov [rbp], rbx"
	asm "add rbp, 8"
end

func ++ i do
	i 1 +
end

func - do	
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	# pop rbx
	asm "sub rbp, 8"
	asm "mov rbx, [rbp]"
	
	asm "sub rbx, rax"
	
	# push rbx
	asm "mov [rbp], rbx"
	asm "add rbp, 8"
end

func -- i do
	i 1 -
end

func * do
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	# pop rbx
	asm "sub rbp, 8"
	asm "mov rbx, [rbp]"
	
	asm "mul rbx"
	
	# push rax
	asm "mov [rbp], rax"
	asm "add rbp, 8"
end

# returns [a / b] [a % b]
func DIVMOD do
	
	# pop rcx (divisor)
	asm "sub rbp, 8"
	asm "mov rcx, [rbp]"
	
	# pop rax (dividend)
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"

	# sign extend rdx
	asm "cqo"
	
	asm "idiv rcx"
	
	# push rax (quotient)
	asm "mov [rbp], rax"
	asm "add rbp, 8"
	
	# push rdx (remainder)
	asm "mov [rbp], rdx"
	asm "add rbp, 8"
end

func / do
	DIVMOD let rem let quo
	quo
end

func % do
	DIVMOD let rem let quo
	rem
end

func >> do
	# pop rcx
	asm "sub rbp, 8"
	asm "mov rcx, [rbp]"
	
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	asm "shr rax, cl"
	
	# push rax
	asm "mov [rbp], rax"
	asm "add rbp, 8"
end

func << a b do
	b 1 < if a ret end
	b 63 > if 0 ret end
	a 2 * b -- <<
end

func AND do
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	# pop rbx
	asm "sub rbp, 8"
	asm "mov rbx, [rbp]"
	
	asm "and rax, rbx"
	
	# push rax
	asm "mov [rbp], rax"
	asm "add rbp, 8"
end

func OR a b do
	a NOT 
	b NOT 
	AND NOT
end

func XOR a b do
	a b NOT AND
	b a NOT AND
	OR
end

func NOT do
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	asm "not rax"
	
	# push rax
	asm "mov [rbp], rax"
	asm "add rbp, 8"
end

func true do 1 end

func false do 0 end

func = do
	asm "mov rcx, 0"
	asm "mov rdx, 1"
	
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	# pop rbx
	asm "sub rbp, 8"
	asm "mov rbx, [rbp]"
	
	asm "cmp rbx, rax"
	asm "cmove rcx, rdx"
	
	# push rcx
	asm "mov [rbp], rcx"
	asm "add rbp, 8"
end

func != a b do
	1 a b = -
end

func > do
	asm "mov rcx, 0"
	asm "mov rdx, 1"
	
	# pop rax
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	# pop rbx
	asm "sub rbp, 8"
	asm "mov rbx, [rbp]"
	
	asm "cmp rax, rbx"
	asm "cmovl rcx, rdx"
	
	# push rcx
	asm "mov [rbp], rcx"
	asm "add rbp, 8"
end

func >= a b do
	1 a b < -
end

func < a b do
	b a >
end

func <= a b do
	1 a b > -
end

func syscall7 num arg1 arg2 arg3 arg4 arg5 arg6 do
	
	num arg1 arg2 arg3 arg4 arg5 arg6
	
	asm "sub rbp, 8"
	asm "mov r9, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov r8, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov r10, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov rdx, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov rsi, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov rdi, [rbp]"
	
	asm "sub rbp, 8"
	asm "mov rax, [rbp]"
	
	asm "push rbp"
	asm "mov rbp, rsp"
	asm "syscall"
	asm "pop rbp"
	
	# this is how a error is detected
	asm "jc .syscall_error"
	
	asm "mov [rbp], rax"
	asm "add rbp, 8"
	asm "jmp .syscall_end"
	
	asm ".syscall_error:"
	asm "mov rax, -1"
	asm "mov [rbp], rax"
	asm "add rbp, 8"
	
	asm ".syscall_end:"
	# return is on the stack
end

