# x86 64 asm

func mem_start do
	asm "lea rax, [rel mem]"
	asm "call push_rax"
end

func sizeof(ptr) do
	8
end

func null do 0 end

func dup x do x x end

func del x do end

# addr value
func !ptr do
	asm "call pop_rbx"
	asm "call pop_rax"
	asm "mov [rax], rbx"
end

# addr
func ?ptr do
	asm "call pop_rax"
	asm "mov rbx, [rax]"
	asm "call push_rbx"
end

# addr value
func !8 do	
	asm "call pop_rbx"
	asm "call pop_rax"
	asm "mov [rax], bl"
end

# addr
func ?8 do
	asm "call pop_rax"
	asm "movzx rbx, byte [rax]"
	asm "call push_rbx"
end

func + do
	asm "call pop_rax"
	asm "call pop_rbx"
	asm "add rbx, rax"
	asm "call push_rbx"
end

func ++ i do
	i 1 +
end

func - do
	asm "call pop_rax"
	asm "call pop_rbx"
	asm "sub rbx, rax"
	asm "call push_rbx"
end

func -- i do
	i 1 -
end

func * do
	asm "call pop_rax"
	asm "call pop_rbx"
	asm "mul rbx"
	asm "call push_rax"
end

# returns [a / b] [a % b]
func DIVMOD do
	asm "call pop_rcx" # divisor
	asm "call pop_rax" # dividend
	asm "cqo" # sign extend rdx
	asm "idiv rcx"
	asm "call push_rax" # quotient
	asm "call push_rdx" # remainder
end

func / do
	DIVMOD let rem let quo
	quo
end

func % do
	DIVMOD let rem let quo
	rem
end

func >> do
	asm "call pop_rcx"
	asm "call pop_rax"
	asm "shr rax, cl"
	asm "call push_rax"
end

func << a b do
	b 1 < if a ret end
	b 63 > if 0 ret end
	a 2 * b -- <<
end

func AND do
	asm "call pop_rax"
	asm "call pop_rbx"
	asm "and rax, rbx"
	asm "call push_rax"
end

func OR a b do
	a NOT 
	b NOT 
	AND NOT
end

func XOR a b do
	a b NOT AND
	b a NOT AND
	OR
end

func NOT do
	asm "call pop_rax"
	asm "not rax"
	asm "call push_rax"
end

func true do 1 end

func false do 0 end

func = do
	asm "mov rcx, 0"
	asm "mov rdx, 1"
	asm "call pop_rax"
	asm "call pop_rbx"
	asm "cmp rbx, rax"
	asm "cmove rcx, rdx"
	asm "call push_rcx"
end

func != a b do
	1 a b = -
end

func > do
	asm "mov rcx, 0"
	asm "mov rdx, 1"
	asm "call pop_rax"
	asm "call pop_rbx"
	asm "cmp rax, rbx"
	asm "cmovl rcx, rdx"
	asm "call push_rcx"
end

func >= a b do
	1 a b < -
end

func < a b do
	b a >
end

func <= a b do
	1 a b > -
end

func syscall7 num arg1 arg2 arg3 arg4 arg5 arg6 do
	
	num arg1 arg2 arg3 arg4 arg5 arg6

	asm "call pop_r9"
	asm "call pop_r8"
	asm "call pop_r10"
	asm "call pop_rdx"
	asm "call pop_rsi"
	asm "call pop_rdi"
	asm "call pop_rax"

	asm "push rbp"
	asm "mov rbp, rsp"
	asm "syscall"
	asm "pop rbp"
	
	# this is how a error is detected
	asm "jc .syscall_error"
	
	asm "call push_rax"

	asm "jmp .syscall_end"
	
	asm ".syscall_error:"

	asm "mov rax, -1"
	asm "call push_rax"

	asm ".syscall_end:"
end

